zerosky

1. Introduction

Problem Statement

This project aims to solve the dual challenges of ensuring data reliability and protecting the privacy of location information and related data generated by IoT devices (especially drones). Specifically, we are addressing the following issues:

Location Privacy Risks: The risk of exposing personal behavioral history and confidential information when raw location data collected by devices is made public.

Data Reliability Issues: The difficulty of verifying that collected location information has not been tampered with, and ensuring the transparency of the verification process itself.

Verification Costs in Decentralized Systems: The high transaction costs and scalability limitations when recording data on Distributed Ledger Technologies (DLT) like blockchains.

Background (Social and Technical Challenges)

With the rapid adoption of drones and other IoT devices in recent years, a massive amount of data is being generated. While this data—particularly location information—is utilized in various fields such as logistics, surveillance, and autonomous driving, concerns regarding its accuracy and privacy protection are growing. Zero-Knowledge Proof (ZKP) is an innovative technology that allows one to prove the truth of an assertion without revealing the specific contents of the information. It is expected to be a powerful solution to these challenges.

Why This Project is Necessary

By applying ZKP technology to IoT data verification, this project enables the following:

Private Proofs: Proving that a drone was at a specific location or followed a specific route without disclosing detailed latitude and longitude information.

Tamper Resistance: Guaranteeing the authenticity and immutability of data by recording ZKPs on the blockchain.

Efficient Verification: Reducing on-chain verification costs by verifying ZKPs via smart contracts while processing complex data off-chain.

Target Use Cases

Drone Flight Path Auditing: Proving to third parties that a drone flew in a specific area while keeping the exact path private.

Ensuring Supply Chain Transparency: Proving the location of packages in logistics using ZKP to enhance tracking reliability.

IoT Device Authentication: Strengthening security by proving that a device is physically present in a specific location.

2. Overview / Abstract

System Summary

This system is an end-to-end solution composed of a Flutter-based mobile client application and a Node.js-based backend server. It uses Zero-Knowledge Proof (ZKP) technology to verify the reliability of location information from IoT devices (drones) and records the proof on a blockchain. Based on the location data acquired by the client, the server generates a ZKP, cross-references it with drone data stored on IPFS, and permanently records the result on the blockchain.

Key Features

Mobile Client (Flutter):

Image capture via camera

Location tracking and history management via GPS

Drone ID detection via Bluetooth LE

Local Poseidon hash generation based on acquired data and performance evaluation (benchmarking)

Security checks (Root detection, developer mode detection, etc.)

Data submission to the server

Local record saving and management in a database

Backend Server (Node.js):

Receiving and storing data (images, hashes, drone IDs) from the client

Uploading data to IPFS and monitoring it (via IPNS)

Generating ZKPs (Groth16) using Circom circuits

Recording generated ZKPs on the blockchain (Ethereum Sepolia)

Managing and tracking submission statuses

Tech Stack

UAV: DJI Matrice 300 RTK + Raspberry Pi 4 (GNSS: ZED-F9P)

Mobile: Google Pixel 8 (Android 14)

Frontend: Flutter (Dart)

Backend: Node.js, Express.js

Zero-Knowledge Proof: Circom, snarkjs (Groth16)

Blockchain Integration: ethers.js (Primarily utilizing Polygon PoS Amoy Testnet)

Decentralized Storage: IPFS

Database: SQLite (Client-side), File System (Server-side)

Security: Libraries referenced in papers (Flutter), such as safe_device (Root detection) and flutter_blue_plus (Remote ID detection)

Target Users

Drone Operating Companies: Companies requiring proof of drone flights and auditing.

Regulatory Authorities: Organizations interested in preventing unauthorized drone use and verifying flight paths.

ZKP Developers: Engineers and researchers interested in real-world applications of ZKP.

Privacy-Conscious Users: Individuals who want their location data handled securely.

3. Architecture

System Architecture Diagram

Data Flow

Data Acquisition (Client: lib/main.dart): The mobile client captures an image via the camera (_controller.takePicture()), acquires GPS location data (_location.onLocationChanged.listen), and detects a specific drone ID (_targetDroneId) via Bluetooth LE (FlutterBluePlus.scanResults.listen).

Local Processing (Client: lib/main.dart): Based on the location data and capture time, the _generateAllHashes function generates Poseidon hashes across multiple time windows and benchmarks the performance. The results are saved to SQLite using LocalDatabaseHelper.instance.createRecord.

Server Submission (Client: lib/main.dart -> Server: server.cjs): The client sends the image file (imageXFile.path), drone ID, and generated hashes to the backend server's /submit endpoint using an http.MultipartRequest inside the _submitApplication function.

Server-side Data Storage (Server: server.cjs): The server's /submit endpoint receives the data via the multer middleware and temporarily stores it in the uploads/ directory. The submission status is recorded in submission-status.json via the updateSubmissionStatus function.

IPFS Upload (Server: server.cjs): Inside the /submit endpoint, the entire submitted directory is uploaded to IPFS using ipfs.addAll, and its CID is recorded via updateSubmissionStatus.

IPFS Watcher (Server: server.cjs): The startIpfsWatcher function allows the server to periodically monitor IPFS/IPNS to detect data updates related to specific drone IDs based on ipns-names.json. The ipfs/retrieve-data.mjs script is called as an external process.

ZKP Generation (Server: server.cjs): When an update is detected by the IPFS watcher, the processAllSubmissions function is executed. This function generates Circom inputs (input.json) via the prepareInputs function, using the drone data retrieved from IPFS and the hashes submitted by the client (read from user_data.json). Then, child_process.execSync is used to calculate the Witness (witness.wtns via snarkjs wtns calculate) and generate the Groth16 proof (proof.json, public.json via snarkjs groth16 prove).

Blockchain Recording (Server: server.cjs): Within the processAllSubmissions function, the generated ZKP's public inputs and proof (calldata generated by snarkjs zkey export soliditycalldata) are recorded on the Ethereum Sepolia blockchain through a deployed smart contract (contract.recordProof) using ethers.js. A transaction hash is issued, and the submission status is updated.

Component Description

Mobile App (Flutter): Uses lib/main.dart as the entry point, providing the UI for camera/GPS/BLE data collection in CameraScreen (_CameraScreenState), local record management in LocalHistoryScreen, and the ZKP submission flow in VerificationScreen. The LocalDatabaseHelper class abstracts the SQLite database.

Backend Server (Node.js): Uses server.cjs as the entry point and defines API endpoints with express. Processes file uploads with multer and executes external ZKP tools (snarkjs) using child_process. Communicates with the blockchain via ethers.js (contract).

Blockchain (Ethereum Sepolia): A smart contract (ABI defined as CONTRACT_ABI) deployed at the address specified in deployed-address.json permanently records ZKP verification results through the recordProof function.

ZKP Circuit (Circom/snarkjs): Executed by the snarkjs command-line tool on the server. It uses ./merkle_js/merkle.wasm (for Witness calculation) and merkle_final.zkey (for Groth16 proof generation) to generate a zero-knowledge proof proving that the provided inputs satisfy specific conditions. ZKP inputs are formatted by the prepareInputs function (./prepare_inputs.js).

IPFS (InterPlanetary File System): Connects to an IPFS node via the ipfs-http-client library. Uploads contents of the uploads/ directory to IPFS and monitors specific drone data updates using ipns-names.json and ipfs/retrieve-data.mjs.

4. Technical Details / Method

Technologies Used

Client:

Flutter (Dart): UI framework. lib/main.dart is the entry point.

camera (package:camera/camera.dart): Device camera access and image capture (_controller.takePicture()).

location (package:location/location.dart): Real-time GPS location tracking (_location.onLocationChanged.listen).

flutter_blue_plus (package:flutter_blue_plus/flutter_blue_plus.dart): Bluetooth LE device scanning and drone ID detection (_startBleScan).

sqflite (package:sqflite/sqflite.dart): Data storage and retrieval to/from a local SQLite database (LocalDatabaseHelper).

poseidon (package:poseidon/poseidon.dart): ZKP-friendly hash function. Calculates hashes from location data on the client side (poseidon3 function).

safe_device (package:safe_device/safe_device.dart): Detects device rooting/jailbreaking and developer mode (_getDeviceUnsafeIssues).

Server:

Node.js: Runtime environment. server.cjs is the entry point.

Express.js: Web application framework. Defines REST API endpoints (e.g., app.post('/submit')).

multer: Handling multipart/form-data. Processes image file uploads from the client (upload.single('image')).

ethers.js: Ethereum blockchain integration. Contract instantiation (new ethers.Contract) and transaction submission (contract.recordProof).

dotenv: Environment variable management. Loads SEPOLIA_RPC_URL and PRIVATE_KEY from a .env file.

ipfs-http-client: IPFS node integration. Adds files (ipfs.addAll) and monitors them (startIpfsWatcher).

child_process: Executes external commands. Calls snarkjs commands (execSync).

ZKP:

Circom: ZKP circuit development language. Circuits are defined in the circom/ directory and compiled as merkle_js/merkle.wasm.

snarkjs: ZKP prover/verifier tool. Used via execSync for Witness generation (snarkjs wtns calculate) and proof generation (snarkjs groth16 prove) using the Groth16 implementation.

merkle_js/merkle.wasm: WebAssembly file compiled from the Circom circuit. Used for Witness calculation.

merkle_final.zkey: The final ZKey (product of the Trusted Setup) used during Groth16 proof generation.

Data Store:

Client: SQLite (zkp_verifier_v3.db). Managed by the LocalDatabaseHelper class.

Server: File System (uploads/, submission-status.json, ipns-names.json). Accessed via fs and fsPromises modules.

API Specifications

Server Endpoints (Defined in server.cjs)

POST /submit

Description: Receives data from the client for ZKP generation. Handled by app.post('/submit', upload.single('image'), ...) in server.cjs.

Format: multipart/form-data

Request Body:

image: Type File. The uploaded image file (accessed as req.file).

hash: Type string. Newline-separated string of hash values generated by the client (accessed as req.body.hash).

droneId: Type string. Drone ID (accessed as req.body.droneId).

captureTime: Type string. Capture time in ISO 8601 format (accessed as req.body.captureTime).

durationSeconds: Type string. The selected duration (accessed as req.body.durationSeconds).

Response: JSON { message: 'Submission accepted.', submissionId: <string> }

Error Response: status 400 (Bad Request) or status 500 (Server Error).

GET /submission-status/:submissionId

Description: Returns the processing status for a specific submissionId. Handled by app.get('/submission-status/:submissionId', ...) in server.cjs.

Format: GET

Path Parameter: submissionId (Type string).

Response: JSON { status: <string>, ipfsCid: <string>?, transactionHash: <string>?, blockNumber: <number>?, performance: <object>?, error: <string>?, lastUpdated: <ISO 8601 string> }

Error Response: status 404 (Submission ID not found).

POST /record-on-chain

Description: Records the ZKP generated on the server to the blockchain. This directly calls the smart contract within the processAllSubmissions function and is not intended to be called directly by the client in the current implementation.

Format: POST (Conceptual. Practically an internal call).

Response: JSON { transactionHash: <string> } (Used in internal processing).

GET /get-proof-events

Description: Fetches and formats ProofRecorded event logs from the smart contract. Handled by app.get('/get-proof-events', ...) in server.cjs.

Format: GET

Response: JSON Array of { transactionHash: <string>, blockNumber: <number>, timestamp: <string>(JST), pubSignals: <string[]> }

Error Response: status 500 (Blockchain connection error, etc.).

Data Structures

LocalRecord (Client-side - SQLite: LocalRecord class in lib/main.dart):

Defines the data structure saved in the records table of the client's local SQLite database zkp_verifier_v3.db.

id: int?. Unique identifier for the record (PRIMARY KEY AUTOINCREMENT).

captureTime: DateTime. Time the data was captured. Saved as TEXT (ISO 8601) format in DB under capture_time.

maxDuration: int. Maximum duration (seconds) for which hashes were generated. Saved as INTEGER in DB under duration_seconds.

droneId: String. The ID of the drone associated with the data. Saved as TEXT in DB under drone_id.

imagePath: String. Local file path of the captured image. Saved as TEXT in DB under image_path.

hashesMap: Map<int, List<String>>. A map where the key is the duration (seconds) and the value is a list of hashes generated for that duration. Saved as TEXT (JSON format) in DB under hashes.

ProcessLog (Client-side - UI Display: ProcessLog class in lib/main.dart):

Data structure for managing UI display states for each step of the ZKP generation and submission process on the VerificationScreen.

name: ProcessName enum. Type of step (hashGeneration, applicationSubmission, chainRecording).

status: ProcessStatus enum. Current state of the step (pending, inProgress, completed, error).

duration: Duration?. Processing time for the step.

errorMessage: String?. Error message if an error occurs.

submissionId: String?. ID for the submission process.

submission-status.json (Server-side: Managed by readStatusFile/writeStatusFile in server.cjs):

A JSON file stored in the server's uploads/ directory to track the processing status of each submission.

Key: submissionId (string). Unique identifier for the submission.

Value: JSON Object.

status: string. Current processing state (e.g., submitted, processing, proof_generated, completed, failed).

ipfsCid: string?. IPFS CID of the submission directory.

transactionHash: string?. Hash of the transaction recorded on the blockchain.

blockNumber: number?. Block number where the transaction was mined.

performance: object?. Performance data such as gas used during blockchain recording.

error: string?. Error message.

lastUpdated: ISO 8601 string. Last update date and time.

ZKP Inputs (Circom input.json):

Input data for the Circom circuit generated via the prepareInputs function (./prepare_inputs.js) inside the processAllSubmissions function of server.cjs.

hashes: Array of hashes submitted by the client (part of the private input).

droneData: Drone data retrieved from IPFS (part of the public input). Example: { publicKey: "...", sensorData: {...} }. (Details are defined in ipfs/retrieve-data.mjs and prepare_inputs.js).

Protocol Design

Client-Server Communication:

HTTPS: The MyHttpOverrides class in lib/main.dart provides settings to accept self-signed certificates (key.pem, cert.pem used by https.createServer in server.cjs) in a development environment. This establishes secure HTTPS communication between the client and server.

API Requests: The client uses http.MultipartRequest to communicate with the API endpoints of server.cjs.

ZKP Generation Protocol (Groth16):

Orchestration: The processAllSubmissions function in server.cjs orchestrates the main steps of ZKP generation.

Setup: merkle_final.zkey is generated during the Trusted Setup phase of Groth16. This file is used in the snarkjs groth16 prove command inside processAllSubmissions.

Witness Calculation: Inside processAllSubmissions, child_process.execSync(\snarkjs wtns calculate ...`) calculates the Witness (witness.wtns) using input.jsongenerated byprepareInputs (./prepare_inputs.js) and merkle_js/merkle.wasm`.

Proof Generation: Inside processAllSubmissions, child_process.execSync(\snarkjs groth16 prove ...`) generates the proof (proof.json) and public inputs (public.json) using merkle_final.zkeyandwitness.wtns`.

Calldata Generation: From the generated proof.json and public.json, child_process.execSync(\snarkjs zkey export soliditycalldata ...`)` generates the calldata for calling the smart contract.

Blockchain Integration:

The contract object in server.cjs is initialized using ethers.js (ethers.JsonRpcProvider, ethers.Wallet, ethers.Contract) with the contract address from deployed-address.json and the CONTRACT_ABI.

Inside processAllSubmissions, the generated calldata is sent to the Ethereum Sepolia blockchain by calling contract.recordProof(pA, pB, pC, pubSignals), permanently recording the ZKP.

Event monitoring uses contract.queryFilter('ProofRecorded') on the app.get('/get-proof-events') endpoint.

IPFS/IPNS:

The IPFS node (ipfs) is initialized using ipfs-http-client (create and globSource) inside the startServer function in server.cjs.

The /submit endpoint uploads the submission directory to IPFS using ipfs.addAll(globSource(submissionDir, '**/*'), { wrapWithDirectory: true }).

The startIpfsWatcher function monitors updates to IPNS entries by referencing ipns-names.json and executing the ipfs/retrieve-data.mjs script via child_process.exec(\node ipfs/retrieve-data.mjs ...`)`.

Algorithms

Poseidon Hash (Client-side: lib/main.dart):

Location data (latitude, longitude, timestamp) is transformed into a center point and surrounding points via the _generateCircularPoints and _pointOnBearing functions.

Instead of simple distance calculations, it applies a proprietary logic called the "5x5 grid search model (rounding to the 4th decimal place)" that accounts for GPS errors.

For each of these points, the ZKP-friendly Poseidon hash function is applied in the format poseidon3([latInt, lonInt, targetTimeInt]) to calculate hash values.

Groth16 (Server-side: server.cjs):

The server's processAllSubmissions function generates a Zero-Knowledge Proof based on the Groth16 protocol via snarkjs, using inputs prepared by prepareInputs (./prepare_inputs.js), merkle_js/merkle.wasm (Witness calculation), and merkle_final.zkey (Proof generation).

Specific ZKP circuit logic is implemented in circom/merkle.circom (or related Circom files), and is presumed to contain the verification logic comparing the submitted hashes against the drone data on IPFS.

5. Setup / Installation

To run this project, you need to set up both the client (Flutter) and server (Node.js) environments.

Prerequisites

Flutter SDK: Latest stable version

Node.js: v18 or higher (LTS recommended)

npm or Yarn: Node.js package manager

Git: Source code management

IPFS Daemon (Optional): If interacting with a local IPFS node

Ethereum Wallet and Sepolia Testnet ETH: For issuing transactions to the blockchain

Dependencies

Client (Flutter)

Dependencies listed in pubspec.yaml will be resolved automatically using the flutter pub get command.

Server (Node.js)

Dependencies listed in package.json will be installed using npm install or yarn install.

Installation Steps

Clone the Repository:

git clone [https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories](https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories)
cd poseidon_hash_zkp/poseidon_client



Client Setup:

cd lib
flutter pub get
# For iOS (first time only)
# cd ios && pod install && cd ..



Server Setup:

cd server
npm install # or yarn install



ZKP Circuit Compilation and Trusted Setup (Development Only):
The ZKP circuits (e.g., circom/merkle.circom) must be compiled in advance to generate merkle_js/merkle.wasm and merkle_final.zkey. If these files do not exist, install circom and snarkjs and execute the following steps.

# Example: Installing Circom and snarkjs
# npm install -g circomlibjs snarkjs

# Compiling the Circom circuit
# circom circom/merkle.circom --wasm --r1cs -o circom/
# mv circom/merkle_js/merkle.wasm merkle_js/

# Trusted Setup (pot19_final.ptau must be obtained separately)
# snarkjs groth16 setup circom/merkle.r1cs pot19_final.ptau merkle_final.zkey



Environment Variables

Create a server/.env file and configure the following variables:

SEPOLIA_RPC_URL: RPC endpoint URL for the Sepolia testnet (e.g., Alchemy, Infura).

PRIVATE_KEY: Private key of your Ethereum wallet used for signing transactions. Never hardcode this directly into the source code in a production environment.

6. Usage

Starting the Server

Run the following command from the project root directory to start the server:

node server.cjs



The server will start listening on https://localhost:3000. Since it uses a self-signed certificate, HTTP override settings are required on the client side (e.g., the MyHttpOverrides class in lib/main.dart).

Running the Client App

Run the following command in the Flutter project root directory to deploy the app to a device or emulator:

flutter run



Demo Steps

Launch the Client App: Open the app on your device. If security checks pass, the camera screen will be displayed.

Detect Drone: The app searches for a specific drone ID (_targetDroneId = D8:3A:DD:E2:55:36) via Bluetooth LE. Wait until the drone is detected (Status displayed: "Connecting: D8:3A:DD:E2:55:36").

Acquire GPS: The app acquires GPS location data (Status displayed: "Acquiring GPS...").

Capture Photo: Tap the shutter button at the bottom of the screen.

Performance Evaluation: The app generates hashes 30 times across multiple durations (10 to 60 seconds) and measures the average processing time. A dialog stating "Running performance evaluation..." will be displayed during this process.

Performance Report: Once the evaluation is complete, the results are displayed in a dialog. There is an option to copy the results in CSV format.

Navigate to Verification Screen: Tap "Proceed" on the report dialog to move to the verification screen.

Select Proof Duration: On the verification screen, select the hash duration to submit to the server (e.g., 30 seconds).

Submit to Server: Tap the "Submit to Server" button. The image and hashes for the selected duration will be sent to the server.

Record on Blockchain: Once the server completes ZKP generation, the "Record on Blockchain" button becomes enabled. Tapping this will record the generated ZKP on Ethereum Sepolia.

Verify Transaction: When recording is complete, the transaction hash is displayed, and you can verify the details on Etherscan.

| | | |
| <img src="assets/safe.jpg" width="200"> | <img src="assets/photo.jpg" width="200"> | <img src="assets/send.jpg" width="200"> |

API Usage Example (Server)

The server's /submit endpoint accepts POST requests in multipart/form-data format.

// Example using Node.js fetch API
const FormData = require('form-data');
const fs = require('fs');

const formData = new FormData();
formData.append('image', fs.createReadStream('/path/to/your/image.jpg'));
formData.append('hash', 'hash1\nhash2\nhash3'); // Hashes generated by the client
formData.append('droneId', 'D8:3A:DD:E2:55:36');
formData.append('captureTime', new Date().toISOString());
formData.append('durationSeconds', '30');

fetch('https://localhost:3000/submit', {
    method: 'POST',
    body: formData,
    // When using a self-signed certificate, you may need to ignore unauthorized errors in Node.js
    // agent: new (require('https').Agent)({ rejectUnauthorized: false })
})
.then(res => res.json())
.then(data => console.log(data))
.catch(error => console.error(error));



7. Evaluation / Benchmark

Performance Evaluation

The client application incorporates a feature to measure the calculation time of the Poseidon hashes, which serve as inputs for ZKP generation.

Metrics: For each specified duration (e.g., 10s, 20s, ..., 60s), Poseidon hashes are generated 30 times based on location data, and the average processing time (in milliseconds) is measured.

Format: Displayed as a tabular report within the application and can be copied to the clipboard in CSV format.

Purpose: To evaluate how different duration settings affect the computational cost of hash generation, which helps in determining optimal parameter settings and understanding the device's processing capabilities.

Experimental Environment

Client

Device: Google Pixel

OS: Android

CPU: Google Tensor Series

Server

Device: Mac (Intel Core i5, 2018)

OS: macOS

CPU: Intel Core i5

RAM: 16GB

Network: Wi-Fi or Wired LAN (for communication between server and client)

Blockchain: Ethereum Sepolia Testnet

Results

Mobile Hash Generation: 0.87 seconds (for 60 seconds of data)

ZKP Proof Generation: Approx. 25 seconds

Gas Fees Comparison: We confirmed that adopting L2 (Polygon PoS Amoy Testnet) significantly reduced gas fees compared to traditional direct recording on L1 (Ethereum Sepolia). (Example: Approx. 113 JPY on Ethereum Sepolia vs. Approx. 0.13 JPY on Polygon PoS Amoy Testnet)

The overhead for client-side security checks was at a negligible level.

Comparison

(This section should also be described based on comparisons with existing research or other methods.)

"Compared to traditional direct data recording on the blockchain, using ZKPs reduced on-chain transaction gas fees by 

$$N$$

%."

"In comparison to similar ZKP-based location proof systems, this system demonstrated superiority in client-side processing performance and efficient off-chain data management."

8. Security Consideration

Since this project combines highly sensitive technologies such as ZKP, IoT, and Blockchain, we have implemented a multi-layered security design.

Threat Model

Malicious Client: Attempting to submit fake location data, fake drone IDs, or tampered hashes to the server.

Server Compromise: A hacked server where the ZKP generation process or IPFS/Blockchain integrations are abused.

Network Attacks: Eavesdropping, tampering, or replay attacks on the communication between the client and server.

Device Compromise: Modifying app behavior via rooting/jailbreaking the client device.

ZKP Circuit Vulnerabilities: Flaws in circuit design leading to the generation of false proofs or privacy leaks.

Smart Contract Vulnerabilities: Contract bugs causing unintended behavior or loss of assets.

Attack Resistance

Privacy via ZKP: By proving specific facts (e.g., a drone was within a specific area during a specific timeframe) without exposing raw location data or detailed drone information, the system protects privacy and is resilient against direct data theft.

Immutability via Blockchain: Once a ZKP is recorded on the blockchain, it cannot be tampered with, guaranteeing the reliability of the proof.

Secure Communication: Communication between the client and server is encrypted via HTTPS (key.pem, cert.pem), preventing eavesdropping and man-in-the-middle attacks.

Anti-Rooting Measures: The client app utilizes the safe_device library to detect device rooting/jailbreaking and developer mode activation, refusing to execute in unsafe environments. This mitigates the risk of app code tampering and unauthorized access to sensitive info (e.g., local DB).

Separation of Concerns: Responsibilities are separated, with the client handling data collection/submission and the server handling ZKP generation/on-chain recording, reducing the risk of a single point of failure.

Privacy Design

Data Concealment via ZKP: Users' specific location coordinates (latitude, longitude) are not directly recorded on the blockchain; only abstracted facts are made public through ZKPs. This minimizes the risk of tracking an individual's movement history.

Use of IPFS: Supplementary information like drone data is stored on IPFS rather than centralized servers, enhancing availability and censorship resistance.

9. Limitations

The current implementation of this project has the following limitations:

ZKP Circuit Complexity: The current ZKP circuits are specialized for specific use cases (e.g., proving a location is within a boundary). Handling more complex logic or larger input data requires redesigning and optimizing the circuits.

Scalability: ZKP generation on the server side is computationally expensive. High volumes of simultaneous submissions may cause processing delays or create server resource bottlenecks.

Network Dependency: Connectivity to IPFS and blockchain networks, as well as their performance, directly affects the system's overall response time.

Self-Signed Certificates: Because the server uses self-signed certificates, additional certificate validation logic is required on the client side, or it needs to be replaced with a certificate issued by a trusted CA.

Generalization of Drone Data: Currently, drone data acquisition relies on IPNS monitoring. Generalization is needed to support various drone models and data formats.

Battery Consumption: GPS tracking and Bluetooth scanning by the client app can consume a relatively large amount of device battery.

Environment Setup Complexity: Setting up the development environment can be complex due to the diverse tech stack, including Flutter, Node.js, IPFS, Circom/snarkjs, and Ethereum.

10. Future Work

We plan to improve and expand this project in the following directions:

Introduction of Advanced ZKP Features:

Developing ZKP circuits that support more complex geospatial queries (e.g., proving passage through multiple checkpoints within a specific timeframe).

Further reducing on-chain verification costs by integrating scaling solutions like ZK-Rollups or Starkware.

Multi-chain Support: Expanding support to other blockchain networks like Polygon and Solana, in addition to Ethereum.

Enhanced Device Integration:

Supporting data collection from a broader range of IoT device types (e.g., vehicle sensors, wearable devices).

Improving tamper resistance at the point of data acquisition by integrating hardware-level security features (e.g., TEE - Trusted Execution Environment).

Optimization of Real-time Processing: Enhancing performance through parallelization and decentralization of ZKP generation on the server, or offloading to WebAssembly.

User Interface Improvements: Further refining the UX/UI of the client app, enhancing submission status visualization and error handling.

Contribution to Standardization: Researching and developing standard protocols and frameworks for data verification combining IoT devices, ZKPs, and blockchains.

Ecosystem Integration: Collaborating with existing IoT platforms and data marketplaces.

11. Contributing

Contributions to this project are welcome. Please follow the guidelines below:

Creating Issues: Please submit bug reports, feature requests, and improvement proposals via the GitHub Issue Tracker.

Creating Pull Requests (PR):

Group your changes into meaningful, small units.

Ensure each PR addresses one specific issue or feature.

Respect existing coding conventions and styles.

Before submitting a PR, ensure that related tests are written and pass successfully.

Include detailed commit messages and a PR description.

Branching Strategy: The main branch is always kept stable. For new features or bug fixes, create a topic branch such as feature/your-feature or bugfix/issue-number, and submit a PR against the main branch.

12. License

(Please include the license information for this project here. Example: MIT License, Apache 2.0 License, etc.)

13. References

Papers on Zero-Knowledge Proofs:

Groth16: On the Size of Pairing-based Non-interactive Arguments

Circom Documentation

snarkjs Documentation

Information on the Poseidon Hash Function:

Poseidon: A New Hash Function for ZKP

IPFS and IPNS:

IPFS Documentation

IPNS Documentation

Ethereum and ethers.js:

Ethereum Documentation

ethers.js Documentation

Flutter:

Flutter Documentation
